
HTTP обладает фичей, которая называется базовая аутентификация. Работает она следующим образом.

![[Pasted image 20230212180858.png]]



При заходе на конкретную страницу или сайт, которые требуют аутентификации, вы увидите окно авторизации. Окно рисуется браузером и требует ввода имени и пароля.

Обычно, если ввести неправильные данные, то браузер запросит их повторно. А если нажать на _Сancel_, то мы получим ошибку с кодом 401. Т.е. при любой попытке зайти на страницу, которая требует базовой авторизации, будет получен ответ 401. При этом нет разницы между отправкой формы с некорректными данными и кликом на кнопку _Сancel_.

В итоге браузер рисует эту форму, когда встречает ошибку 401. Работает она очень просто: либо вы отсылаете правильный заголовок, либо получаете ошибку 401. Никакой магии, никаких вариантов действий.

Давайте посмотрим, какие данные требуются при таком взаимодействии:

```
HTTP/1.1 401 Access Denied
WWW-Authenticate: Basic realm="My Server"
Content-Length: 0
```

Вы не можете зайти и получаете `Access Denied` и заголовок от сервера `WWW-Authenticate: Basic realm="My Server"`. В этом заголовке есть ключ, значение которого выводится в диалоговом окне. Больше оно нигде не используется.

После ввода логина и пароля происходит отправка следующих заголовков:


```
GET /securefiles/ HTTP/1.1
Host: www.httpwatch.com
Authorization: Basic aHR0cHdhdGNoDmY=
```

Во-первых, это стандартные заголовки для HTTP 1.1. Во-вторых (и это самое главное), заголовок _Authorization_, в котором есть обязательное слово `Basic` и после пробела закодированая фраза. Эта фраза состоит из имени пользователя и пароля — `<username>:<password>`, закодированных в _base64_.

Этого достаточно. После отправки корректных данных происходит аутентификация, и вы получаете доступ на сайт или страницу, к которому обратились.

Чтобы получить закодированое слово нужно написать

```
printf 'username:password' | base64
```
Получим закодированное слово, которое можно будте потом использовать


Любой веб-проект достаточно быстро перестает помещаться в рамках одного пакета: становится слишком много views и urlpatterns. Чтобы контролировать процесс роста, мы можем использовать стандартный для Python прием **декомпозиции** — превращение модуля в пакет с подмодулями.

В случае _views.py_ это даже сработает. Но разделить на части **правила роутинга** — элементы списка `urlpatterns` в _urls.py_ — будет уже сложновато. Придется вручную собирать список правил из отдельных кусочков.

Django позволяет не придумывать свои способы управления сложностью. В фреймворке уже есть готовый паттерн — **приложения** или **applications**.

В этом уроке разберем, как приложения помогают организовать код в больших проектах, а также научимся создавать его и добавлять маршрутизацию.

Каждое приложение представляет собой пакет с модулями, который включает в себя модуль описания моделей и вьюх. Также в него часто входят свои шаблоны и свои же urlpatterns. Приложения часто выглядят как миниатюрные, но самостоятельные веб-приложения. Эта самостоятельность помогает реализовывать переиспользуемые приложения, которые решают типовые задачи.

Сам фреймворк Django предоставляет набор таких приложений-кирпичиков, которые помогают быстро заложить фундамент проекта.

## Создаем первое приложение

У нас уже есть одно приложение — пакет _hexlet_django_blog_. Самый первый пакет, который мы создаем при запуске `django-admin startproject`, может и не быть приложением. Его задача: описать точки входа в веб-приложение. В этом пакете задаются настройки всего приложения и корневые urlpatterns.

Мы сделали пакет _hexlet_django_blog_ приложением, когда добавили его в `settings.INSTALLED_APPS`.

Этот список содержит перечень всех Django applications, которые подключены к текущему проекту. Многие механизмы фреймворка обращаются к этому перечню во время своей работы. Так встроенный загрузчик шаблонов (Template Loader) ищет их в поддиректориях с именем _templates_ во всех подключенных приложениях. Для этого мы подключили `hexlet_django_blog` в роли приложения — чтобы загрузчик шаблонов нашел наш первый шаблон.

Чтобы создать новое приложение, нужно перейти в директорию пакета _hexlet_django_blog_ и выполнить `django-admin startapp article`. В результате создастся приложение следующего вида с точки зрения корня проекта:

```
tree hexlet_django_blog/article

hexlet_django_blog/article
├── admin.py
├── apps.py
├── __init__.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py
```

Здесь модуль _models.py_ и пакет _migrations_ относятся к слою хранения. Он пока нас не интересуют. _tests.py_ описывает тесты, _admin.py_ описывает админку — на это мы тоже пока не обращаем внимание. А вот _views.py_ нам пригодится.

Чтобы закончить создание болванки приложения, остается задать его имя в файле _apps.py_ и подключить в `settings.INSTALLED_APPS`. Для этого в качестве имени мы указываем полный путь к приложению:

```
# hexlet_django_blog/article/apps.py
class ActicleConfig(AppConfig):
    ...
    name = 'hexlet_django_blog.article'  # <- изменяем эту строчку
```

Далее добавляем имя приложения в список:

```
# hexlet_django_blog/settings.py
INSTALLED_APPS = [
    ...
    'hexlet_django_blog',
    'hexlet_django_blog.article',  # <- добавляем эту строчку
]
```

Приложение создано и подключено.

## Добавляем маршрутизацию

По умолчанию в приложении не генерируется модуль _urls.py_. Дело в том, что приложение может и не быть настолько большим, чтобы потребовался отдельный набор правил маршрутизации. Такие небольшие приложения прописывают в _urls.py_ уровнем выше. Но мы будем делать большое приложение, поэтому смело создаем файл _hexlet_django_blog/article/urls.py_ следующего вида:

```
from django.urls import path

from hexlet_django_blog.article import views

urlpatterns = [
    path('', views.index),
]
```

Пока все максимально похоже на корневой urls.py — мы снова связали пустой путь с вьюхой _views.index_, но уже из этого приложения.

Теперь нужно связать urlpatterns приложения с urlpatterns проекта. Модифицируем _hexlet_django_blog/urls.py_:

```
from django.urls import path, include  # <- добавлен include

from hexlet_django_blog import views

urlpatterns = [
    path('', views.index),
    path('article/', include('hexlet_django_blog.article.urls')),  # <- новая строчка
    path('admin/', admin.site.urls),
]
```

С этого момента все пути, которые начинаются с "article/", будут перенаправляться в `hexlet_django_blog.article.urls`. В приложении у нас уже приписана view `index`, которая связана с путем `''`. Это означает, что запрос по пути `article/` без каких либо продолжений будет направлен в `hexlet_django_blog.article.views.index`.

Мы встроили приложение в проект по префиксу пути. Переиспользуемые приложения обычно встраиваются именно таким образом. Префикс `article/` задается вне встраиваемого приложения, поэтому приложение может быть встроено в любой проект по любому префиксу. И правила маршрутизации этого приложения не будут конфликтовать с правилами проекта и других приложений.

## Реализуем view

View у нас прописана в правилах маршрутизации. Реализуем ее:

```
# hexlet_django_blog/article/views.py
from django.http import HttpResponse

def index(request):
    return HttpResponse('article')
```

Если теперь открыть в браузере адрес `localhost:8000/article/`, то мы увидим текст "article".

Здесь view возвращает `HttpResponse` с указанным телом ответа, вместо того чтобы использовать шаблон. В модуле [django.http](https://docs.djangoproject.com/en/4.1/ref/request-response) вы найдете `JsonResponse`, который позволяет возвращать данные в виде JSON и `FileResponse`. Он нужен для отправки клиенту файлов.